## 这是一个示例问题

这是一个示例解决办法。

注：多个问题之间需要使用分隔线进行分隔。

---

## 缺失的原图导致列表接口崩溃

**问题描述**：

- 列表序列化缩略图时直接打开磁盘文件，原图被删除/移动后 `generate_thumbnail` 抛出 `FileNotFoundError`，接口返回 500。
- 编辑接口在备份阶段直接复制原图，文件缺失同样导致进程报错并中断。

**解决办法**：

1. 列表序列化前检查源文件是否存在，缺失时仅输出 warning 并跳过该条数据，分页接口不中断。
2. 缩略图生成与编辑备份阶段发现缺失文件时返回 404（同时记录 warning），避免异常直接崩溃。
3. 补齐文件后重新请求会自动恢复缩略图与列表展示，无需额外操作。

---

## Connexion 3.x 在 ASGI 模式下 `request.get_json()` 报错

**问题描述**：
在使用 `uvicorn` 启动 Connexion 应用时，`connexion.request` 是 Starlette 请求对象的代理。由于 Starlette 的请求处理是异步 的，它不支持 Flask 风格的同步 `get_json()` 方法。直接调用会导致 `AttributeError: 'Request' object has no attribute 'get_json'`，从而触发 500 错误。

**解决办法**：
遵循 Connexion 的最佳实践，放弃手动调用 `request.get_json()`，改为使用**参数注入（Parameter Injection）**。

1. 在 OpenAPI 规范中定义好 `requestBody`。
2. 在对应的 Python 处理函数签名中添加 `body` 参数（或规范中定义的具体参数名）。
3. Connexion 框架会自动解析请求体并将其作为参数传递给函数。

例如：

```python
# 修改前
def login():
    payload = request.get_json()

# 修改后
def login(body):
    payload = body
```

对于 `multipart/form-data` 上传，同样可以使用参数注入直接获取 `file` 和其他表单字段。

---

## 单图编辑无预览接口导致前端只能提交后查看结果

**问题描述**：

- 只有裁剪/色调的落盘接口，前端无法在参数变动时获取编辑后的效果图，用户容易误解或误操作。

**解决办法**：

1. 在 `backend/src/api/images.py` 新增 `preview_edit`，沿用裁剪/色调的参数校验与权限校验，返回内存生成的 `image/png`。
2. 在 `backend/src/utils/image_ops.py` 抽出 `_apply_crop/_apply_hue` 并提供 `build_edit_preview`，避免落盘即可生成预览。
3. 前端调用 `/api/images/{id}/edit/preview`，等待时用计算尺寸的占位+转圈提示，结果返回后替换为预览图。

---

## 迁移数据后外链返回 `/api/images/images/...` 导致前端大图 404

**问题描述**：

- 未设置 `links.public_base_url` 时，`_build_public_image_url` 使用 `request.base_url`，实际请求路径是 `/api/images`，拼出的外链多了路径前缀（`/api/images/images/{relpath}`），迁移导入的图片在瀑布流和详情页请求大图时均返回 404。

**解决办法**：

1. 后端公共链接构造改为默认取 `request.host_url` 仅保留域名与端口，避免携带当前请求路径。
2. 列表排序增加 `id` 逆序作为副排序，保证分页稳定且不依赖 ID 表示时间。
3. 重新拉取列表后外链指向 `/images/{relpath}`，迁移图片可正常加载。

---

## 后端 image.py 内部报错

- 没有 request.host_url，请使用 request.base_url。

---

## 迁移脚本看不到新增记录（查错了数据库路径）

**问题描述**：

- 运行 `migration/migrate_images.py` 后，`backend/data/app.db` 中的 `images` 表没有新增记录，看起来像脚本未写入。
- 实际配置 `database.url` 指向 `sqlite:///./data/app.db`，脚本与后端都在写项目根目录下的 `data/app.db`。

**解决办法**：

1. 检查/查询的数据库文件改为 `data/app.db`（与 config.yaml 保持一致），或在配置中显式改为 `sqlite:///./backend/data/app.db` 后再次迁移。
2. 已存在记录的 `created_at`/`updated_at` 不再被迁移脚本覆盖，避免重复跑迁移时篡改上传时间。

---

## 浏览页切换回瀑布流后卡片高度固定为 100px

**问题描述**：

- 在列表视图切回瀑布流后，所有图片卡片高度被夹到 100px，原因是瀑布流容器在列表视图下被卸载，旧的 ResizeObserver 仍收到 0 宽度回调，导致列宽被计算为负数，最终显示高度被限制到最小值。

**解决办法**：

1. 在瀑布流容器宽度监听中增加 `layout` 依赖，切换视图时重新注册 ResizeObserver。
2. 对列宽计算加下限保护，宽度不可用时设置为 0，避免高度被强制压到最小值。

---

## 浏览页切换视图后继续沿用旧分页导致卡顿

**问题描述**：

- 在瀑布流滚动加载了大量图片后切换到列表视图，React Query 仍沿用之前累积的分页数据，导致列表一次性渲染过多图片，切换时体验卡顿。

**解决办法**：

1. 增加视图切换计数写入 `useInfiniteQuery` 的 `queryKey`，每次切换都强制重新从第一页加载数据。
2. 同时清空瀑布流的列元数据，确保新数据按最新视图重新排布，切换后页面从 20 张开始展示。

---

## 裁剪后宽高未更新导致基础信息显示旧尺寸

**问题描述**：

- 裁剪接口仅落盘新图，没有回写 `image_dimensions`，详情页继续展示裁剪前的宽高。
- 前端裁剪后只刷新原图，未强制重新获取元数据，基础信息不会更新。

**解决办法**：

1. 后端在 `after_edit` 中重新读取落盘文件尺寸，更新/补全 `image_dimensions`，同时刷新文件大小并失效缩略图。
2. 前端裁剪成功后重置加载状态，依次 refetch 详情并重新获取缩略图和原图，确保宽高与展示一致。

---

## dev.py 启动后端时提示 `/bin/sh: 1: source: not found`

**问题描述**：

- `dev.py` 默认用 `/bin/sh` 运行启动命令，`source` 不是 `sh` 的内建命令，导致虚拟环境无法激活，后端进程未启动。

**解决办法**：

- `subprocess.Popen` 在类 Unix 环境下改为指定 `executable="/bin/bash"`，强制使用 bash 执行 `source .venv/bin/activate && python app.py`，确保激活环境后再启动服务。

---

## 请求 AI 标签时提示 missing dependency for socks support

**问题描述**：

- 运行 AI 标签生成请求时，`requests` 检测到环境中的 SOCKS 代理（如 `ALL_PROXY=socks5h://...`），但缺少对应依赖，抛出 `Missing dependencies for SOCKS support`，请求直接失败。

**解决办法**：

1. 在后端依赖中新增 `PySocks`（或改用 `requests[socks]`）。
2. 重新安装后端依赖后重启服务，确保 SOCKS 代理可被 `requests` 正确识别。

---

## 后端读取 app.db 指向错误目录

**问题描述**：

- `database.url` 使用 `sqlite:///./data/app.db` 时，后端从当前工作目录解析相对路径。
- 以 `backend` 目录作为工作目录启动服务或测试，会导致实际写入 `backend/data/app.db`，而预期文件应在与 `config.yaml` 同级的 `data/app.db`。

**解决办法**：

1. 在数据库初始化时规范化 sqlite URL，将相对路径按项目根目录（与 `config.yaml` 同级）解析为绝对路径。
2. 目录创建与引擎初始化均使用规范化后的路径，确保所有运行方式都指向同一份数据库文件。

---

## 瀑布流初始空白触发多页加载

**问题描述**：

- 瀑布流触底加载依赖 IntersectionObserver，但图片需要先下载获得宽高后才加入布局。
- 初始布局为空时哨兵一直处于可视状态，导致连续触发 `fetchNextPage`，一次性加载多页。

**解决办法**：

1. 记录哨兵可视状态，不直接在回调中请求下一页。
2. 统计当前瀑布流图片是否全部加载完成，仅在“全部加载完成 + 哨兵仍可见”时才允许触发下一页加载。
3. 切换视图时重置哨兵状态，避免旧状态误触发。

---

## 浏览页使用静态外链加载原图导致未走后端 API

**问题描述**：

- 浏览页瀑布流/列表在展示原图时直接使用 `public_url`（静态外链），与“仅复制链接使用静态外链、其他场景走后端 API”的要求不符。

**解决办法**：

1. 在浏览页新增 `buildAuthedFileUrl`，统一拼接 `/api/images/{id}/file` 并携带 token 作为查询参数。
2. 瀑布流、列表、以及用于计算宽高的 `ImageLoader` 全部改用该 API 链接加载原图。
3. 复制链接仍保留 `public_url`，避免影响外链分享。

---

## 图片文件接口带 query token 仍返回 401

**问题描述**：

- 前端以 `/api/images/{id}/file?token=...` 加载原图时返回 401。
- Connexion 的 `bearerAuth` 安全校验只读取 `Authorization` 头，忽略 query token，导致安全层在进入接口前就拒绝请求。

**解决办法**：

1. 在 `bearer_info` 中仅对 `/api/images/{id}/file` 读取 query token，允许 JWT 直链通过安全校验。
2. 其余接口仍保持只接受 `Authorization` 头，避免扩大 query token 的使用范围。

---

## 原图接口鉴权导致浏览/详情 401

**问题描述**：

- `<img>` 直接请求 `/api/images/{id}/file` 无法携带 `Authorization` 头，导致后端鉴权返回 401。
- query token 方案仍可能在安全校验层被拒绝，影响原图展示。

**解决办法**：

1. 前端原图展示统一改为 `public_url`（`/images/{year}/{month}/{day}/{filename}`）直链。
2. 公开直链接口保持 `security: []` 不鉴权，依赖年月日 + hash 做直链保护。
3. 复制链接与原图展示共用该地址，减少鉴权干扰。

---

## 使用 /images 相对路径后开发环境无法加载、复制链接缺少 hostname

**问题描述**：

- 前端改用 `/images/...` 相对路径后，Vite dev 未代理该路径，请求被发往前端服务导致 404。
- 复制链接直接使用相对路径，分享时缺少 hostname。

**解决办法**：

1. Vite dev 代理新增 `/images` 指向后端，保证开发环境可加载图片。
2. 展示时将 `public_url` 转成相对路径，确保走同源代理。
3. 复制链接时统一补齐 hostname，确保外链可直接访问。

---

## 详情页原图请求带 v 参数触发 400

**问题描述**：

- 详情页为了刷新缓存，在原图地址后追加 `?v=updated_at`。
- Connexion 开启 `strict_validation` 后，`/images/{year}/{month}/{day}/{filename}` 未声明 query 参数，导致请求被判定为非法并返回 400。

**解决办法**：

1. 在 `openapi.yaml` 的 `/images/{year}/{month}/{day}/{filename}` 中新增可选 `v` query 参数。
2. 保持后端仍按路径定位文件，`v` 仅用于缓存刷新，不参与业务逻辑。
