## 这是一个示例问题

这是一个示例解决办法。

注：多个问题之间需要使用分隔线进行分隔。

---

## Connexion 3.x 在 ASGI 模式下 `request.get_json()` 报错

**问题描述**：
在使用 `uvicorn` 启动 Connexion 应用时，`connexion.request` 是 Starlette 请求对象的代理。由于 Starlette 的请求处理是异步 的，它不支持 Flask 风格的同步 `get_json()` 方法。直接调用会导致 `AttributeError: 'Request' object has no attribute 'get_json'`，从而触发 500 错误。

**解决办法**：
遵循 Connexion 的最佳实践，放弃手动调用 `request.get_json()`，改为使用**参数注入（Parameter Injection）**。

1. 在 OpenAPI 规范中定义好 `requestBody`。
2. 在对应的 Python 处理函数签名中添加 `body` 参数（或规范中定义的具体参数名）。
3. Connexion 框架会自动解析请求体并将其作为参数传递给函数。

例如：

```python
# 修改前
def login():
    payload = request.get_json()

# 修改后
def login(body):
    payload = body
```

对于 `multipart/form-data` 上传，同样可以使用参数注入直接获取 `file` 和其他表单字段。

---

## 单图编辑无预览接口导致前端只能提交后查看结果

**问题描述**：

- 只有裁剪/色调的落盘接口，前端无法在参数变动时获取编辑后的效果图，用户容易误解或误操作。

**解决办法**：

1. 在 `backend/src/api/images.py` 新增 `preview_edit`，沿用裁剪/色调的参数校验与权限校验，返回内存生成的 `image/png`。
2. 在 `backend/src/utils/image_ops.py` 抽出 `_apply_crop/_apply_hue` 并提供 `build_edit_preview`，避免落盘即可生成预览。
3. 前端调用 `/api/images/{id}/edit/preview`，等待时用计算尺寸的占位+转圈提示，结果返回后替换为预览图。

---

## 迁移数据后外链返回 `/api/images/images/...` 导致前端大图 404

**问题描述**：

- 未设置 `links.public_base_url` 时，`_build_public_image_url` 使用 `request.base_url`，实际请求路径是 `/api/images`，拼出的外链多了路径前缀（`/api/images/images/{relpath}`），迁移导入的图片在瀑布流和详情页请求大图时均返回 404。

**解决办法**：

1. 后端公共链接构造改为默认取 `request.host_url` 仅保留域名与端口，避免携带当前请求路径。
2. 列表排序增加 `id` 逆序作为副排序，保证分页稳定且不依赖 ID 表示时间。
3. 重新拉取列表后外链指向 `/images/{relpath}`，迁移图片可正常加载。

---

## 后端 image.py 内部报错

- 没有 request.host_url，请使用 request.base_url。

---

## 迁移脚本看不到新增记录（查错了数据库路径）

**问题描述**：
- 运行 `migration/migrate_images.py` 后，`backend/data/app.db` 中的 `images` 表没有新增记录，看起来像脚本未写入。
- 实际配置 `database.url` 指向 `sqlite:///./data/app.db`，脚本与后端都在写项目根目录下的 `data/app.db`。

**解决办法**：
1. 检查/查询的数据库文件改为 `data/app.db`（与 config.yaml 保持一致），或在配置中显式改为 `sqlite:///./backend/data/app.db` 后再次迁移。
2. 已存在记录的 `created_at`/`updated_at` 不再被迁移脚本覆盖，避免重复跑迁移时篡改上传时间。

---

## 迁移脚本插入时报 `NOT NULL constraint failed: images.original_filename`

**问题描述**：
- 新增图片时 JSONL 缺少 `original_name`，脚本将 `original_filename` 写入 None，与历史数据库约束（非空）冲突。

**解决办法**：
1. 迁移脚本默认使用文件名（hash.ext）填充 `original_filename`，仅当 JSONL 提供时才覆盖。
2. 重新执行迁移，验证不再触发 original_filename 的非空约束。

---

## 浏览页切换回瀑布流后卡片高度固定为 100px

**问题描述**：
- 在列表视图切回瀑布流后，所有图片卡片高度被夹到 100px，原因是瀑布流容器在列表视图下被卸载，旧的 ResizeObserver 仍收到 0 宽度回调，导致列宽被计算为负数，最终显示高度被限制到最小值。

**解决办法**：
1. 在瀑布流容器宽度监听中增加 `layout` 依赖，切换视图时重新注册 ResizeObserver。
2. 对列宽计算加下限保护，宽度不可用时设置为 0，避免高度被强制压到最小值。

---

## 浏览页切换视图后继续沿用旧分页导致卡顿

**问题描述**：
- 在瀑布流滚动加载了大量图片后切换到列表视图，React Query 仍沿用之前累积的分页数据，导致列表一次性渲染过多图片，切换时体验卡顿。

**解决办法**：
1. 增加视图切换计数写入 `useInfiniteQuery` 的 `queryKey`，每次切换都强制重新从第一页加载数据。
2. 同时清空瀑布流的列元数据，确保新数据按最新视图重新排布，切换后页面从 20 张开始展示。

---

## 回到顶部按钮滚动不平滑

**问题描述**：
- 回到顶部按钮点击后瞬间跳到顶部，没有使用浏览器原生的平滑滚动效果。

**解决办法**：
1. 在 `frontend/src/components/ScrollTopButton.tsx` 中优先使用 `document.scrollingElement` 触发 `scrollTo({ behavior: "smooth" })`，兼容部分浏览器对 `window.scrollTo` 的实现差异。
2. 继续保留 `html { scroll-behavior: smooth; }` 的全局样式，确保其他跳转也使用平滑滚动。

---

## 详情页原图加载依赖缩略图导致空白且无骨架

**问题描述**：
- 详情页原图组件只有在缩略图 onLoad 后才渲染，缩略图失败或缓慢时原图一直不出现，用户只看到空白区域且没有骨架占位。
- 图片元数据包含宽高，却未利用尺寸生成占位，加载中的布局会抖动。

**解决办法**：
1. 原图组件独立渲染，仅用 `fullLoaded` 控制透明度，避免依赖缩略图的加载结果。
2. 使用元数据宽高计算 `aspect-ratio`，在缩略图与原图未加载时显示等比例骨架，加载后按“骨架 -> 缩略图 -> 原图”顺序切换。

---

## 详情页 Hook 调用顺序变动导致报错

**问题描述**：
- 给详情页增加骨架后，将 `useMemo` 放在 `if (!data) return null;` 之后，导致数据未加载时渲染提前返回，下一次渲染执行更多 Hook，触发 “Rendered more hooks than during the previous render”。

**解决办法**：
1. 将依赖 `data` 的 `useMemo` 和加载状态计算放到早于返回语句的位置，确保无条件执行 Hook。
2. 返回条件保留在 Hook 之后，避免再次出现 Hook 顺序变动的风险。
3. `useMemo` 的依赖与内部读取统一使用可选链（如 `data?.dimensions`），防止数据未返回时读取 undefined 引发异常。

---

## 导出脚本误判表结构导致查询 images 表报错

**问题描述**：
- 以为数据库有 `images` 表，直接查询 `storage_relpath`/`original_filename`，实际 SQLite 只有 `history` 表，字段为 `filename/url/created_at` 等，脚本运行会失败。

**解决办法**：
1. 使用 `sqlite3 data/PicUploader.db ".schema"` 确认真实表结构，改为读取 `history` 表。
2. 从 `url` 路径末尾提取 `年/月/日/文件名` 生成相对路径，`filename` 作为 `original_name`，`created_at` 转 ISO 写入 JSONL。
3. 更新 `migration/export_upload_history.py` 与设计文档描述，避免后续再次误用表名。 

---

## 裁剪后宽高未更新导致基础信息显示旧尺寸

**问题描述**：
- 裁剪接口仅落盘新图，没有回写 `image_dimensions`，详情页继续展示裁剪前的宽高。
- 前端裁剪后只刷新原图，未强制重新获取元数据，基础信息不会更新。

**解决办法**：
1. 后端在 `after_edit` 中重新读取落盘文件尺寸，更新/补全 `image_dimensions`，同时刷新文件大小并失效缩略图。
2. 前端裁剪成功后重置加载状态，依次 refetch 详情并重新获取缩略图和原图，确保宽高与展示一致。
