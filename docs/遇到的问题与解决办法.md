## 这是一个示例问题

这是一个示例解决办法。

注：多个问题之间需要使用分隔线进行分隔。

---

## Connexion 3.x 在 ASGI 模式下 `request.get_json()` 报错

**问题描述**：
在使用 `uvicorn` 启动 Connexion 应用时，`connexion.request` 是 Starlette 请求对象的代理。由于 Starlette 的请求处理是异步 的，它不支持 Flask 风格的同步 `get_json()` 方法。直接调用会导致 `AttributeError: 'Request' object has no attribute 'get_json'`，从而触发 500 错误。

**解决办法**：
遵循 Connexion 的最佳实践，放弃手动调用 `request.get_json()`，改为使用**参数注入（Parameter Injection）**。

1. 在 OpenAPI 规范中定义好 `requestBody`。
2. 在对应的 Python 处理函数签名中添加 `body` 参数（或规范中定义的具体参数名）。
3. Connexion 框架会自动解析请求体并将其作为参数传递给函数。

例如：

```python
# 修改前
def login():
    payload = request.get_json()

# 修改后
def login(body):
    payload = body
```

对于 `multipart/form-data` 上传，同样可以使用参数注入直接获取 `file` 和其他表单字段。

---

## 单图编辑无预览接口导致前端只能提交后查看结果

**问题描述**：

- 只有裁剪/色调的落盘接口，前端无法在参数变动时获取编辑后的效果图，用户容易误解或误操作。

**解决办法**：

1. 在 `backend/src/api/images.py` 新增 `preview_edit`，沿用裁剪/色调的参数校验与权限校验，返回内存生成的 `image/png`。
2. 在 `backend/src/utils/image_ops.py` 抽出 `_apply_crop/_apply_hue` 并提供 `build_edit_preview`，避免落盘即可生成预览。
3. 前端调用 `/api/images/{id}/edit/preview`，等待时用计算尺寸的占位+转圈提示，结果返回后替换为预览图。

---

## 迁移数据后外链返回 `/api/images/images/...` 导致前端大图 404

**问题描述**：

- 未设置 `links.public_base_url` 时，`_build_public_image_url` 使用 `request.base_url`，实际请求路径是 `/api/images`，拼出的外链多了路径前缀（`/api/images/images/{relpath}`），迁移导入的图片在瀑布流和详情页请求大图时均返回 404。

**解决办法**：

1. 后端公共链接构造改为默认取 `request.host_url` 仅保留域名与端口，避免携带当前请求路径。
2. 列表排序增加 `id` 逆序作为副排序，保证分页稳定且不依赖 ID 表示时间。
3. 重新拉取列表后外链指向 `/images/{relpath}`，迁移图片可正常加载。

---

## 后端 image.py 内部报错

- 没有 request.host_url，请使用 request.base_url。

---

## 迁移脚本看不到新增记录（查错了数据库路径）

**问题描述**：

- 运行 `migration/migrate_images.py` 后，`backend/data/app.db` 中的 `images` 表没有新增记录，看起来像脚本未写入。
- 实际配置 `database.url` 指向 `sqlite:///./data/app.db`，脚本与后端都在写项目根目录下的 `data/app.db`。

**解决办法**：

1. 检查/查询的数据库文件改为 `data/app.db`（与 config.yaml 保持一致），或在配置中显式改为 `sqlite:///./backend/data/app.db` 后再次迁移。
2. 已存在记录的 `created_at`/`updated_at` 不再被迁移脚本覆盖，避免重复跑迁移时篡改上传时间。

---

## 浏览页切换回瀑布流后卡片高度固定为 100px

**问题描述**：

- 在列表视图切回瀑布流后，所有图片卡片高度被夹到 100px，原因是瀑布流容器在列表视图下被卸载，旧的 ResizeObserver 仍收到 0 宽度回调，导致列宽被计算为负数，最终显示高度被限制到最小值。

**解决办法**：

1. 在瀑布流容器宽度监听中增加 `layout` 依赖，切换视图时重新注册 ResizeObserver。
2. 对列宽计算加下限保护，宽度不可用时设置为 0，避免高度被强制压到最小值。

---

## 浏览页切换视图后继续沿用旧分页导致卡顿

**问题描述**：

- 在瀑布流滚动加载了大量图片后切换到列表视图，React Query 仍沿用之前累积的分页数据，导致列表一次性渲染过多图片，切换时体验卡顿。

**解决办法**：

1. 增加视图切换计数写入 `useInfiniteQuery` 的 `queryKey`，每次切换都强制重新从第一页加载数据。
2. 同时清空瀑布流的列元数据，确保新数据按最新视图重新排布，切换后页面从 20 张开始展示。

---

## 裁剪后宽高未更新导致基础信息显示旧尺寸

**问题描述**：

- 裁剪接口仅落盘新图，没有回写 `image_dimensions`，详情页继续展示裁剪前的宽高。
- 前端裁剪后只刷新原图，未强制重新获取元数据，基础信息不会更新。

**解决办法**：

1. 后端在 `after_edit` 中重新读取落盘文件尺寸，更新/补全 `image_dimensions`，同时刷新文件大小并失效缩略图。
2. 前端裁剪成功后重置加载状态，依次 refetch 详情并重新获取缩略图和原图，确保宽高与展示一致。

---

## dev.py 启动后端时提示 `/bin/sh: 1: source: not found`

**问题描述**：

- `dev.py` 默认用 `/bin/sh` 运行启动命令，`source` 不是 `sh` 的内建命令，导致虚拟环境无法激活，后端进程未启动。

**解决办法**：

- `subprocess.Popen` 在类 Unix 环境下改为指定 `executable="/bin/bash"`，强制使用 bash 执行 `source .venv/bin/activate && python app.py`，确保激活环境后再启动服务。
